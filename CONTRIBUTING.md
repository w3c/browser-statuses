# Contributing

We welcome contributions! If you believe that some implementation info should be
added, modified, fixed or removed from the list, consider submitting a pull
request, taking the considerations below into account. Alternatively, feel free
to [raise an issue](https://github.com/w3c/browser-statuses/issues/new).

Please note the open source data and code [license](LICENSE.md) for this
project.


## Table of Contents

- [Pre-requisites](#pre-requisites)
- [Implementation info comes for external platform status projects](#implementation-info-comes-for-external-platform-status-projects)
- [The actual list is in the `data` folder](#the-actual-list-is-in-the-data-folder)
- [No `index.json` in the pull request](#no-indexjson-in-the-pull-request)


## Pre-requisites

To prepare a pull request, please:
- install [Node.js](https://nodejs.org/en/) if not already done,
- fork this Git repository,
- install dependencies through a call to `npm install`


## Implementation info comes for external platform status projects

The implementation information in the `index.json` file is generated by
collecting information external platform status projects:
- [Can I Use](https://caniuse.com/)
- [Chrome Platform Status](https://www.chromestatus.com/)
- [MDN's Browser Compatilibity Data](https://github.com/mdn/browser-compat-data)
- [Webkit Platform Status](https://webkit.org/status/)

If the implementation information is incorrect, the information should better be
fixed at the source. If that is not possible, or as temporary workaround, there
exists an exception mechanism in this project to specify the implementation
information manually, see below. This should only be used as last resort.


## The actual list is in the `data` folder

The `index.json` file is automatically generated by processing the contents of
the `data` folder and mapping its contents to the implementation information
collected from external platform status projects.

Each file in the folder is a JSON file with the following structure:

```json
{
  "statusref": {
    "bcd": "bcd.identifier",
    "caniuse": "Can I Use identifier",
    "chrome": 1337,
    "webkit": "specification-identifier",
    "manual": [
      {
        "ua": "user agent identifier",
        "status": "implementation status",
        "source": "feedback or other",
        "date": "YYYY-MM-DD",
        "comment": "Rationale for including this implementation info manually"
      }
    ]
  },
  "features": {
    "feature name": {
      "url": "URL of the section that defines the feature in the spec",
      "title": "Human readable description of the feature",
      "statusref": ["same construct as at the root level"]
    }
  },
  "polyfills": [
    {
      "url": "URL of a polyfill library",
      "label": "Name of the polyfill library"
    }
  ],
  "notes": [
    "Possible notes on this information"
  ]
}
```

Each file in the `data` folder must be named after the
[`shortname`](README.md#shortname) of the specification series it describes.

The `statusref` creates the mapping between the specification series (or an
individual feature) and corresponding entries in external platform status
projects. Possible keys and values may be:
* `bcd`: the [hierarchy of strings](https://github.com/mdn/browser-compat-data/blob/master/schemas/compat-data-schema.md#feature-hierarchies) that identifies the feature in the [MDN Browser Compatibility Data](https://github.com/mdn/browser-compat-data)
* `caniuse`: the name of the feature in [Can I use](http://caniuse.com/) (the one that appears in the URL after `#feat=`)
* `chrome`: the number used to identify features in [Chrome Platform Status](https://www.chromestatus.com/features) (the one that appears in the URL after `features/`)
* `webkit`: the name used to identify features in [WebKit Feature Status](https://webkit.org/status/) (the one that appears in the URL after `status/#`)
* `manual`: manually entered implementation status. See below for details.

From time to time, external platform status projects may:
* contain implementation information about the specification but at a different granularity level, e.g. you want implementation info about the entire specification and the site only gives implementation status about a particular feature within the specification, or the opposite
* contain implementation information which you know is *incorrect*.
* not contain any information about a specification at all

When this happens, you may use the `manual` sub-property to specify
implementation status manually. Property value must be an array of objects that
have the following properties:
* `ua`: the user agent name (typically one of `edge`, `firefox`, `chrome`, `safari`, `webkit`)
* `status`: the implementation status, which should be one of `shipped`, `indevelopment`, `experimental`, `consideration`, or an empty string to say "Not currently considered".
* `source` (optional but recommended): a short name that identifies the origin of the information. Use `feedback` to flag information that comes from review and that should override whatever other implementation status the framework might be able to retrieve automatically for the user agent under consideration.
* `date` (optional but recommended): the `YYYY-MM-DD` date at which that manually information was last reviewed. Keeping implementation information up to date is difficult and error prone. The information needs to be periodically checked and re-validated. The date is meant to track the last time when someone checked and validated the information.
* `comment` (optional but recommended): a comment that provides contextual information, for instance to explain why the information in platform status sources should be regarded as incorrect.
* `prefix` (optional): whether the implementation requires the use of a prefix
* `flag` (optional): whether some flag needs to be set to enable the feature

You should **only** set properties when there values are meaningful. For
instance, no need to include an empty `notes` property.

Automated tests will enforce that files in the `data` folder follow the
appropriate schema. You may run these tests locally, and make sure that the
information can be processed correctly through:

```bash
npm test
npm run build
```


## No `index.json` in the pull request

The `index.json` file will be automatically generated once your pull request has
been merged. Please do not include it in your pull request. You may still wish
to [re-generate the file](README.md#how-to-generate-indexjson-manually) if you
want to check that the generated info will be correct, but please don't commit
these changes.
